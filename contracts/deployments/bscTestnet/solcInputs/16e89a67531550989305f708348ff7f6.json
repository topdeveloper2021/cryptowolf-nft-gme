{
  "language": "Solidity",
  "sources": {
    "contracts/Claim.sol": {
      "content": "/*\nCRYPTOWOLF\nWeb: https://cryptowolf.finance\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n// import \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./DateTimeLibrary.sol\";\n\ncontract Claim is\n    Initializable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable\n{\n    using SafeMathUpgradeable for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    bool public isInitialized;\n\n    uint8 topLevel;\n    uint256 reductionBasisPoints;\n    address public CWOLFContractAddress;\n    address public HuntingNFTContractAddress;\n    address public rewardsPoolAddress;\n\n    mapping(address => bool) public usersRegistered;\n    mapping(address => uint256) public usersAmount;\n    mapping(address => uint8) public usersPenalizationLevel;\n    mapping(address => uint256) public usersTaxAmount;\n    mapping(address => uint256) public dateUsersLastReduction;\n    mapping(address => uint256) public dateUsersLastHunt;\n    mapping(address => uint256) public usersLastDayHunt;\n    mapping(address => uint256) public usersLastMonthHunt;\n    mapping(address => uint256) public usersLastYearHunt;\n\n    mapping(uint8 => uint256) public levelsPercentages;\n\n    event Deposit(address indexed user, uint256 indexed amountDeposited);\n    event ClaimReward(\n        address indexed user,\n        uint256 indexed amountClaimed,\n        uint256 indexed penalizationAmount\n    );\n\n    constructor() initializer {}\n\n    function initialize(\n        address HuntingNFTContractAddress_,\n        address CWOLFContractAddress_,\n        address rewardsPoolAddress_\n    ) public initializer {\n        __Ownable_init();\n        isInitialized = true;\n\n        HuntingNFTContractAddress = HuntingNFTContractAddress_;\n        CWOLFContractAddress = CWOLFContractAddress_;\n        rewardsPoolAddress = rewardsPoolAddress_;\n        levelsPercentages[0] = 4500;\n        levelsPercentages[1] = 5400;\n        levelsPercentages[2] = 6300;\n        levelsPercentages[3] = 7200;\n        levelsPercentages[4] = 8100;\n        levelsPercentages[5] = 9000;\n\n        reductionBasisPoints = 300;\n        topLevel = 5;\n        // Uncomment if we want deploy paused\n        // _pause();\n    }\n\n    function addReward(address _userAddress, uint256 _rewardAmount) external {\n        require(\n            msg.sender == HuntingNFTContractAddress,\n            \"Caller is not Hunting Contract\"\n        );\n        usersAmount[_userAddress] = usersAmount[_userAddress] + _rewardAmount;\n\n        // Si el usuario no está registrado, preparamos todos sus datos\n        if(!usersRegistered[_userAddress]){\n            _setUser(_userAddress);\n        }\n\n        // Comprobamos si se le quita penalización, si ya ha cazado hoy, no se le quita más\n        if (checkIfCanDecreasePenalization(_userAddress)) {\n            decreasePenalizationAmount(_userAddress, 1);\n        }\n        // Seteamos los datos de hoy respecto a la caza\n        dateUsersLastHunt[_userAddress] = block.timestamp;\n\n        emit Deposit(_userAddress, _rewardAmount);\n    }\n\n    function claimReward() external {\n        \n        uint256 _days = DateTimeLibrary.diffDays(\n            dateUsersLastReduction[msg.sender],\n            block.timestamp\n        );\n        decreasePenalizationAmount(msg.sender, _days);\n\n        uint256 _feeAmount = (usersAmount[msg.sender] *\n            usersTaxAmount[msg.sender]) / 10000;\n        uint256 _amountToClaim = usersAmount[msg.sender] - _feeAmount;\n\n        IERC20Upgradeable(CWOLFContractAddress).transferFrom(\n            rewardsPoolAddress,\n            msg.sender,\n            _amountToClaim\n        );\n\n        usersAmount[msg.sender] = 0;\n\n        if (usersTaxAmount[msg.sender] > 0) {\n            usersPenalizationLevel[msg.sender] = usersPenalizationLevel[msg.sender] < topLevel\n                ? usersPenalizationLevel[msg.sender] + 1\n                : topLevel;\n            usersTaxAmount[msg.sender] = levelsPercentages[\n                usersPenalizationLevel[msg.sender]\n            ];\n        }\n\n        emit ClaimReward(\n            msg.sender,\n            _amountToClaim,\n            usersTaxAmount[msg.sender]\n        );\n    }\n\n    function decreasePenalizationAmount(\n        address _userAddress,\n        uint256 _amountOfDays\n    ) public {\n        require(\n            msg.sender == owner() ||\n                msg.sender == HuntingNFTContractAddress ||\n                msg.sender == address(this),\n            \"Caller is not owner or Hunting contract\"\n        );\n        uint256 totalBasisPointsToReduce = reductionBasisPoints * _amountOfDays;\n        if(totalBasisPointsToReduce > usersTaxAmount[_userAddress]) {\n            usersTaxAmount[_userAddress] = 0;\n        }\n        else{\n            usersTaxAmount[_userAddress] = usersTaxAmount[_userAddress] - totalBasisPointsToReduce;\n        }\n        dateUsersLastReduction[_userAddress] = block.timestamp;\n    }\n\n    function changeReductionBasisPoints(uint256 _newReductionBasisPoints)\n        external\n        onlyOwner\n    {\n        reductionBasisPoints = _newReductionBasisPoints;\n    }\n\n    function checkIfCanDecreasePenalization(address _userAddress)\n        public\n        view\n        returns (bool)\n    {\n        uint256 day = DateTimeLibrary.getDay(block.timestamp);\n        uint256 month = DateTimeLibrary.getMonth(block.timestamp);\n        uint256 year = DateTimeLibrary.getYear(block.timestamp);\n        return\n            DateTimeLibrary.getDay(dateUsersLastHunt[_userAddress]) != day &&\n            DateTimeLibrary.getMonth(dateUsersLastHunt[_userAddress]) != month &&\n            DateTimeLibrary.getYear(dateUsersLastHunt[_userAddress]) != year;\n    }\n\n    function changeHuntingNFTContractAddress(\n        address _newHuntingNFTContractAddress\n    ) external onlyOwner {\n        HuntingNFTContractAddress = _newHuntingNFTContractAddress;\n    }\n\n    function _setUser(address _userAddress) internal {\n        usersPenalizationLevel[_userAddress] = 0;\n        usersTaxAmount[_userAddress] = levelsPercentages[\n            usersPenalizationLevel[_userAddress]\n        ];\n        usersRegistered[_userAddress] = true;\n        dateUsersLastReduction[_userAddress] = block.timestamp;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/DateTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary DateTimeLibrary {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 constant SECONDS_PER_MINUTE = 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    uint256 constant DOW_MON = 1;\n    uint256 constant DOW_TUE = 2;\n    uint256 constant DOW_WED = 3;\n    uint256 constant DOW_THU = 4;\n    uint256 constant DOW_FRI = 5;\n    uint256 constant DOW_SAT = 6;\n    uint256 constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 _days) {\n        require(year >= 1970);\n        int256 _year = int256(year);\n        int256 _month = int256(month);\n        int256 _day = int256(day);\n\n        int256 __days = _day -\n            32075 +\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\n            4 +\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\n            12 -\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\n            4 -\n            OFFSET19700101;\n\n        _days = uint256(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n\n    function timestampFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n\n    function timestampFromDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 timestamp) {\n        timestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            hour *\n            SECONDS_PER_HOUR +\n            minute *\n            SECONDS_PER_MINUTE +\n            second;\n    }\n\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint256 daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n\n    function isValidDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n\n    function isLeapYear(uint256 timestamp)\n        internal\n        pure\n        returns (bool leapYear)\n    {\n        (uint256 year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n\n    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n\n    function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n\n    function getDaysInMonth(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 daysInMonth)\n    {\n        (uint256 year, uint256 month, ) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n\n    function _getDaysInMonth(uint256 year, uint256 month)\n        internal\n        pure\n        returns (uint256 daysInMonth)\n    {\n        if (\n            month == 1 ||\n            month == 3 ||\n            month == 5 ||\n            month == 7 ||\n            month == 8 ||\n            month == 10 ||\n            month == 12\n        ) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 dayOfWeek)\n    {\n        uint256 _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = ((_days + 3) % 7) + 1;\n    }\n\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getDay(uint256 timestamp) internal pure returns (uint256 day) {\n        (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getHour(uint256 timestamp) internal pure returns (uint256 hour) {\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n\n    function getMinute(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 minute)\n    {\n        uint256 secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n\n    function getSecond(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 second)\n    {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint256 timestamp, uint256 _years)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        year += _years;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp >= timestamp);\n    }\n\n    function addMonths(uint256 timestamp, uint256 _months)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        month += _months;\n        year += (month - 1) / 12;\n        month = ((month - 1) % 12) + 1;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp >= timestamp);\n    }\n\n    function addDays(uint256 timestamp, uint256 _days)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addHours(uint256 timestamp, uint256 _hours)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addMinutes(uint256 timestamp, uint256 _minutes)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addSeconds(uint256 timestamp, uint256 _seconds)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint256 timestamp, uint256 _years)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        year -= _years;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp <= timestamp);\n    }\n\n    function subMonths(uint256 timestamp, uint256 _months)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        uint256 yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = (yearMonth % 12) + 1;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp <= timestamp);\n    }\n\n    function subDays(uint256 timestamp, uint256 _days)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subHours(uint256 timestamp, uint256 _hours)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subMinutes(uint256 timestamp, uint256 _minutes)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subSeconds(uint256 timestamp, uint256 _seconds)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _years)\n    {\n        require(fromTimestamp <= toTimestamp);\n        (uint256 fromYear, , ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint256 toYear, , ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _months)\n    {\n        require(fromTimestamp <= toTimestamp);\n        (uint256 fromYear, uint256 fromMonth, ) = _daysToDate(\n            fromTimestamp / SECONDS_PER_DAY\n        );\n        (uint256 toYear, uint256 toMonth, ) = _daysToDate(\n            toTimestamp / SECONDS_PER_DAY\n        );\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _days)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _hours)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _minutes)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _seconds)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/PresaleCWOLF.sol": {
      "content": "/*\nCRYPTOWOLF\nWeb: https://cryptowolf.finance\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./DateTimeLibrary.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract PresaleCWOLF is\n    Initializable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    bool public isInitialized;\n\n    mapping(address => uint256) public boughtTokens;\n    mapping(address => uint256) public claimedTokens;\n\n    address public tokenAddress;\n    bool public claimActive;\n\n    uint256 public firstReleaseDateTs;\n\n    event Claim(address indexed addressClaim, uint256 amount);\n    event ChangedClaimState(bool newState);\n\n    constructor() initializer {}\n\n    function initialize(address tokenAddress_) public initializer {\n        __Ownable_init();\n        tokenAddress = tokenAddress_;\n        claimActive = false;\n        changeFirstReleaseDateTs(uint256(16756675200)); // Year 2500\n        isInitialized = true;\n\n        // Uncomment if we want deploy paused\n        // _pause();\n    }\n\n    function maxAmountToClaim(address _address)\n        internal\n        view\n        returns (uint256)\n    {\n        // Calculamos los días desde firstReleaseDateTs hasta block.timestamp.\n        // Cada día liberamos un 1% más.\n        uint256 diffDays = DateTimeLibrary.diffDays(\n            firstReleaseDateTs,\n            block.timestamp\n        );\n\n        if (diffDays >= 100) {\n            diffDays = 100;\n        }\n\n        uint256 maxAmount = (boughtTokens[_address] * diffDays * 100) / 10000;\n\n        return maxAmount;\n    }\n\n    function claim(uint256 _amountToClaim)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (bool)\n    {\n        require(claimActive, \"Claim not active\");\n        uint256 maxTokensAmountToClaim = maxAmountToClaim(msg.sender);\n\n        require(\n            _amountToClaim + claimedTokens[msg.sender] <=\n                maxTokensAmountToClaim,\n            \"Amount exceeded\"\n        );\n\n        claimedTokens[msg.sender] = claimedTokens[msg.sender] + _amountToClaim;\n\n        IERC20Upgradeable(tokenAddress).transfer(msg.sender, _amountToClaim);\n        emit Claim(msg.sender, _amountToClaim);\n        return true;\n    }\n\n    function remainingTokensUser(address _address)\n        public\n        view\n        returns (uint256)\n    {\n        return boughtTokens[_address] - claimedTokens[_address];\n    }\n\n    function toBeClaimedNow(address _address) external view returns (uint256) {\n        return maxAmountToClaim(_address) - claimedTokens[_address];\n    }\n\n    function changeFirstReleaseDateTs(uint256 _newFirstReleaseDateTs)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        firstReleaseDateTs = _newFirstReleaseDateTs;\n        return true;\n    }\n\n    function addAddresses(\n        address[] memory _addresses,\n        uint256[] memory _amountTokens\n    ) external onlyOwner {\n        require(\n            _addresses.length == _amountTokens.length,\n            \"Not equal dimensions\"\n        );\n\n        for (uint256 index = 0; index < _addresses.length; index++) {\n            boughtTokens[_addresses[index]] =\n                boughtTokens[_addresses[index]] +\n                _amountTokens[index] *\n                1e18;\n        }\n    }\n\n    function removeAddresses(address[] memory _addresses) external onlyOwner {\n        for (uint256 index = 0; index < _addresses.length; index++) {\n            boughtTokens[_addresses[index]] = 0;\n        }\n    }\n\n    function setTokenAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        tokenAddress = _newAddress;\n        return true;\n    }\n\n    function changeClaimState(bool _newState)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        claimActive = _newState;\n        emit ChangedClaimState(_newState);\n        return true;\n    }\n\n    function pause() external onlyOwner returns (bool) {\n        _pause();\n        return true;\n    }\n\n    function unpause() external onlyOwner returns (bool) {\n        _unpause();\n        return true;\n    }\n\n    function withdraw() external onlyOwner returns (bool) {\n        uint256 balance = address(this).balance;\n        payable(owner()).transfer(balance);\n        return true;\n    }\n\n    function withdrawRemainingTokens(uint256 _amount)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        IERC20Upgradeable(tokenAddress).transfer(msg.sender, _amount);\n        return true;\n    }\n\n    function withdrawToken(address _tokenAddress, uint256 _amount)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        IERC20Upgradeable(_tokenAddress).transfer(msg.sender, _amount);\n        return (true);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\n    function __ERC20Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20Pausable_init_unchained();\n    }\n\n    function __ERC20Pausable_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/MaterialsNFT.sol": {
      "content": "/*\nCRYPTOWOLF\nWeb: https://cryptowolf.finance\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./Random.sol\";\nimport \"./Variables.sol\";\nimport \"./WolfPacksNFT.sol\";\n\ncontract MaterialsNFT is\n    Initializable,\n    ERC721EnumerableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable\n{\n    using SafeMathUpgradeable for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    bool public isInitialized;\n    uint256 public boxPriceCWOLFInDollars;\n    uint256 public gasToMinter;\n    uint256 public commissionInDollars;\n    address public rewardsPoolAddress;\n    address public CWOLFContractAddress;\n    address public VariablesContractAddress;\n    address public minterWalletAddress;\n    address public commissionWalletAddress;\n    string public strBaseTokenURI;\n\n    uint256[] public materialsProbabilities;\n\n    mapping(uint256 => uint256) public slots;\n    mapping(uint256 => bool) public generated;\n\n    address public WolfPackNFTContractAddress;\n\n    event MintedNFT(address indexed to, uint256 indexed id);\n    event GeneratedNFT(uint256 indexed id);\n\n    constructor() initializer {}\n\n    function initialize(\n        address CWOLFContractAddress_,\n        address VariablesContractAddress_,\n        address rewardsPoolAddress_,\n        address minterWalletAddress_,\n        address commissionWalletAddress_\n    ) public initializer {\n        __ERC721_init(\"MaterialsNFT\", \"MaterialsNFT\");\n        __Ownable_init();\n        isInitialized = true;\n        CWOLFContractAddress = CWOLFContractAddress_;\n        VariablesContractAddress = VariablesContractAddress_;\n        rewardsPoolAddress = rewardsPoolAddress_;\n        gasToMinter = 1000000000000000;\n        minterWalletAddress = minterWalletAddress_;\n        commissionWalletAddress = commissionWalletAddress_;\n        commissionInDollars = 250000000000000000;\n        boxPriceCWOLFInDollars = 10000000000000000000;\n        materialsProbabilities = [54, 78, 90, 96, 99, 100];\n\n        // First CAVE must be 0 capacity\n        _safeMint(minterWalletAddress_, 0);\n\n        // Uncomment if we want deploy paused\n        // _pause();\n    }\n\n    function mintOwner(address _to) external onlyOwner returns (uint256) {\n        return mint(_to);\n    }\n\n    function mintWithCWOLF(uint8 _amount)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (bool)\n    {\n        uint256 commissionInBNB = Variables(VariablesContractAddress)\n            .getDollarsInBNB(commissionInDollars);\n        require(_amount <= 10, \"Amount must be < 10\");\n        require(\n            msg.value >= ((gasToMinter * _amount) + commissionInBNB),\n            \"Not enough gas\"\n        );\n        payable(minterWalletAddress).transfer(gasToMinter * _amount);\n        payable(commissionWalletAddress).transfer(commissionInBNB);\n        payable(msg.sender).transfer(\n            msg.value - ((gasToMinter * _amount) + commissionInBNB)\n        );\n\n        require(\n            IERC20Upgradeable(CWOLFContractAddress).allowance(\n                msg.sender,\n                address(this)\n            ) >= boxPriceCWOLFInDollars,\n            \"Not enough allowance\"\n        );\n\n        uint256 amountCWOLF = Variables(VariablesContractAddress)\n            .getDollarsInCWOLF(boxPriceCWOLFInDollars) * _amount;\n\n        IERC20Upgradeable(CWOLFContractAddress).transferFrom(\n            msg.sender,\n            rewardsPoolAddress,\n            amountCWOLF\n        );\n\n        for (uint256 index = 0; index < _amount; index++) {\n            mint(msg.sender);\n        }\n\n        return true;\n    }\n\n    function mint(address _to) internal returns (uint256) {\n        uint256 tokenId = totalSupply();\n        _safeMint(_to, tokenId);\n        emit MintedNFT(_to, tokenId);\n        return tokenId;\n    }\n\n    function calculateGasAndCommissions(uint8 _amount)\n        public\n        view\n        returns (uint256[3] memory)\n    {\n        uint256 commissionInBNB = Variables(VariablesContractAddress)\n            .getDollarsInBNB(commissionInDollars);\n\n        uint256[3] memory commissions;\n        commissions[0] = gasToMinter * _amount;\n        commissions[1] = commissionInBNB * _amount;\n        commissions[2] = ((gasToMinter * _amount) +\n            (commissionInBNB * _amount));\n        return commissions;\n    }\n\n    function burnMaterial(uint256 _tokenId) public returns (bool) {\n        require(ownerOf(_tokenId) == msg.sender, \"Owner of MaterialNFT failed\");\n        \n        bool isUsed = WolfPacksNFT(WolfPackNFTContractAddress).materialsUsed(_tokenId);\n        require(isUsed == false, \"Material cannot be burned during its use\");\n\n        safeTransferFrom(msg.sender, rewardsPoolAddress, _tokenId);\n\n        uint256 amountCWOLF = Variables(VariablesContractAddress)\n            .getDollarsInCWOLF(boxPriceCWOLFInDollars);\n\n        uint256 amountToReturn = (amountCWOLF * 2000) / 10000;\n\n        IERC20Upgradeable(CWOLFContractAddress).transferFrom(\n            rewardsPoolAddress,\n            msg.sender,\n            amountToReturn\n        );\n\n        return true;\n    }\n\n    function getMaterialSlots(uint256 _tokenId) public view returns (uint256) {\n        return slots[_tokenId];\n    }\n\n    function generateValuesMaterials(uint256[] memory _tokenIds, bytes32 _seed)\n        external\n        returns (bool)\n    {\n        for (uint256 index = 0; index < _tokenIds.length; index++) {\n            uint256 tokenId = _tokenIds[index];\n\n            require(generated[tokenId] == false, \"NFT yet generated\");\n\n            require(tokenId != 0, \"Not allowed\");\n            require(\n                msg.sender == owner() || msg.sender == minterWalletAddress,\n                \"Not allowed\"\n            );\n            require(_exists(tokenId), \"Token does not exist\");\n\n            uint256 random = Random.randomMinMax(\n                keccak256(abi.encodePacked(_seed, index)),\n                0,\n                100\n            );\n\n            uint256 randomSlots;\n            if (random < materialsProbabilities[0]) {\n                randomSlots = 1;\n            } else if (\n                random >= materialsProbabilities[0] &&\n                random < materialsProbabilities[1]\n            ) {\n                randomSlots = 2;\n            } else if (\n                random >= materialsProbabilities[1] &&\n                random < materialsProbabilities[2]\n            ) {\n                randomSlots = 3;\n            } else if (\n                random >= materialsProbabilities[2] &&\n                random < materialsProbabilities[3]\n            ) {\n                randomSlots = 4;\n            } else if (\n                random >= materialsProbabilities[3] &&\n                random < materialsProbabilities[4]\n            ) {\n                randomSlots = 5;\n            } else if (\n                random >= materialsProbabilities[4] &&\n                random <= materialsProbabilities[5]\n            ) {\n                randomSlots = 6;\n            }\n\n            slots[tokenId] = randomSlots;\n            generated[tokenId] = true;\n\n            emit GeneratedNFT(tokenId);\n        }\n        return true;\n    }\n\n    function changeMaterialsProbabilities(uint256[] memory _newArray)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        require(_newArray.length == 6, \"Array length must be 6\");\n        materialsProbabilities = _newArray;\n        return true;\n    }\n\n    function walletOfOwner(address _owner)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256 tokenCount = balanceOf(_owner);\n        uint256[] memory tokensId = new uint256[](tokenCount);\n        for (uint256 i = 0; i < tokenCount; i++) {\n            tokensId[i] = tokenOfOwnerByIndex(_owner, i);\n        }\n        return tokensId;\n    }\n\n    function changeBaseTokenURI(string memory newBaseTokenURI)\n        external\n        onlyOwner\n    {\n        strBaseTokenURI = newBaseTokenURI;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return strBaseTokenURI;\n    }\n\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        require(_exists(_tokenId), \"Token does not exist\");\n        return string(abi.encodePacked(_baseURI(), _tokenId.toString()));\n    }\n\n    function pause() external onlyOwner returns (bool) {\n        _pause();\n        return true;\n    }\n\n    function unpause() external onlyOwner returns (bool) {\n        _unpause();\n        return true;\n    }\n\n    function changeCWOLFContractAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        CWOLFContractAddress = _newAddress;\n        return true;\n    }\n\n    function changeRewardsPoolAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        rewardsPoolAddress = _newAddress;\n        return true;\n    }\n\n    function changeboxPriceCWOLFInDollars(uint256 _newPrice)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        boxPriceCWOLFInDollars = _newPrice;\n        return true;\n    }\n\n    function changeGasToMinter(uint256 _newValue)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        gasToMinter = _newValue;\n        return true;\n    }\n\n    function changeCommissionInDollars(uint256 _newValue)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        commissionInDollars = _newValue;\n        return true;\n    }\n\n    function changeAddressMinterWallet(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        minterWalletAddress = _newAddress;\n        return true;\n    }\n\n    function changeAddressCommissionWallet(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        commissionWalletAddress = _newAddress;\n        return true;\n    }\n\n    function changeWolfPackNFTContractAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        WolfPackNFTContractAddress = _newAddress;\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721Enumerable_init_unchained();\n    }\n\n    function __ERC721Enumerable_init_unchained() internal initializer {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n    uint256[46] private __gap;\n}\n"
    },
    "contracts/Random.sol": {
      "content": "/*\nCRYPTOWOLF\nWeb: https://cryptowolf.finance\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary Random {\n    function randomMinMax(\n        bytes32 _seed,\n        uint256 _min,\n        uint256 _max\n    ) internal pure returns (uint256) {\n        uint256 diff = _max - _min + 1;\n\n        uint256 seed = uint256(keccak256(abi.encode(_seed))) % diff;\n\n        return seed + _min;\n    }\n}\n"
    },
    "contracts/Variables.sol": {
      "content": "/*\nCRYPTOWOLF\nWeb: https://cryptowolf.finance\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract Variables is OwnableUpgradeable {\n    bool public isInitialized;\n    uint256 public priceCWOLF;\n    uint256 public priceBNB;\n    address public minterWalletAddress;\n\n    event PriceCWOLFChanged(uint256 newPrice);\n    event PriceBNBChanged(uint256 newPrice);\n    event PriceCWOLFAndBNBChanged(uint256 _newPriceCWOLF, uint256 _newPriceBNB);\n\n    constructor() initializer {}\n\n    function initialize(address minterWalletAddress_) public initializer {\n        __Ownable_init();\n        priceCWOLF = 8 * 1e17;\n        priceBNB = 500000000000000000000;\n        minterWalletAddress = minterWalletAddress_;\n        isInitialized = true;\n    }\n\n    function setCWolfPriceInDollars(uint256 _newPrice) external {\n        require(\n            msg.sender == owner() || msg.sender == minterWalletAddress,\n            \"Not allowed\"\n        );\n        priceCWOLF = _newPrice;\n        emit PriceCWOLFChanged(_newPrice);\n    }\n\n    function getDollarsInCWOLF(uint256 _amount)\n        external\n        view\n        returns (uint256)\n    {\n        return (_amount * 1e18) / priceCWOLF;\n    }\n\n    function setBNBPriceInDollars(uint256 _newPrice) external {\n        require(\n            msg.sender == owner() || msg.sender == minterWalletAddress,\n            \"Not allowed\"\n        );\n        priceBNB = _newPrice;\n        emit PriceBNBChanged(_newPrice);\n    }\n\n    function getDollarsInBNB(uint256 _amount) external view returns (uint256) {\n        return (_amount * 1e18) / priceBNB;\n    }\n\n    function setCWOLFAndBNBPriceInDollars(\n        uint256 _newPriceCWOLF,\n        uint256 _newPriceBNB\n    ) external {\n        require(\n            msg.sender == owner() || msg.sender == minterWalletAddress,\n            \"Not allowed\"\n        );\n        priceCWOLF = _newPriceCWOLF;\n        priceBNB = _newPriceBNB;\n        emit PriceCWOLFAndBNBChanged(_newPriceCWOLF, _newPriceBNB);\n    }\n\n    function changeAddressMinterWallet(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        minterWalletAddress = _newAddress;\n        return true;\n    }\n}\n"
    },
    "contracts/WolfPacksNFT.sol": {
      "content": "/*\nCRYPTOWOLF\nWeb: https://cryptowolf.finance\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./WolfsNFT.sol\";\nimport \"./MaterialsNFT.sol\";\nimport \"./Hunting.sol\";\nimport \"./Variables.sol\";\nimport \"./DateTimeLibrary.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract WolfPacksNFT is\n    Initializable,\n    ERC721EnumerableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable\n{\n    using SafeMathUpgradeable for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    bool public isInitialized;\n    uint256 public addWolfOrMaterialCWOLFInDollar;\n    uint256 public gasToMinter;\n    uint256 public energyPointPriceInCWOLF;\n    uint256 public commissionInDollar;\n    address public rewardsPoolAddress;\n    address public commissionWalletAddress;\n    address public CWOLFContractAddress;\n    address public HuntingNFTContractAddress;\n    address public WolfsNFTContractAddress;\n    address public MaterialsNFTContractAddress;\n    address public VariablesContractAddress;\n    address public minterWalletAddress;\n    string public strBaseTokenURI;\n\n    mapping(uint256 => uint256[]) public wolfsInWolfPack;\n    mapping(uint256 => uint256[]) public materialsInWolfPack;\n\n    mapping(uint256 => bool) public wolfsUsed;\n    mapping(uint256 => bool) public materialsUsed;\n    mapping(uint256 => uint256) public wolfPackLife;\n    mapping(uint256 => uint256) public wolfPackEnergy;\n    mapping(uint256 => uint256) public wolfPackLinkDays;\n    mapping(uint256 => uint256) public wolfPackLinkDate;\n    mapping(uint256 => uint256) public lastHunting;\n    mapping(uint256 => bool) configurationLinkDays;\n\n    bool public isPromoActive;\n    mapping(uint256 => bool) public wolfPackInPromo;\n    uint256 public dateLastPromoActivation;\n    uint256 public daysOfPromo;\n\n    event MintedNFT(address indexed _to, uint256 indexed _id);\n    event IncreasedEnergy(uint256 indexed _wolfPackId, uint256 indexed _amount);\n    event DecreasedEnergy(uint256 indexed _wolfPackId, uint256 indexed _amount);\n    event IncreasedLink(uint256 indexed _wolfPackId, uint256 indexed _amount);\n    event DecreasedLink(uint256 indexed _wolfPackId, uint256 indexed _amount);\n    event IncreasedLife(uint256 indexed _wolfPackId, uint256 indexed _amount);\n    event DecreasedLife(uint256 indexed _wolfPackId, uint256 indexed _amount);\n\n    constructor() initializer {}\n\n    function initialize(\n        address CWOLFContractAddress_,\n        address rewardsPoolAddress_,\n        address minterWalletAddress_,\n        address WolfsNFTContractAddress_,\n        address MaterialsNFTContractAddress_,\n        address VariablesContractAddress_,\n        address commissionWalletAddress_\n    ) public initializer {\n        __ERC721_init(\"WolfPacksNFT\", \"WolfPacksNFT\");\n        __Ownable_init();\n        isInitialized = true;\n        CWOLFContractAddress = CWOLFContractAddress_;\n        rewardsPoolAddress = rewardsPoolAddress_;\n        gasToMinter = 1000000000000000;\n        commissionInDollar = 250000000000000000;\n        energyPointPriceInCWOLF = 1000000000000000000;\n        minterWalletAddress = minterWalletAddress_;\n        commissionWalletAddress = commissionWalletAddress_;\n        WolfsNFTContractAddress = WolfsNFTContractAddress_;\n        MaterialsNFTContractAddress = MaterialsNFTContractAddress_;\n        VariablesContractAddress = VariablesContractAddress_;\n        addWolfOrMaterialCWOLFInDollar = 250000000000000000;\n        configurationLinkDays[1] = true;\n        configurationLinkDays[3] = true;\n        configurationLinkDays[14] = true;\n        configurationLinkDays[30] = true;\n\n        // First WOLFPACK must be 0 capacity\n        _safeMint(minterWalletAddress_, 0);\n\n        // Uncomment if we want deploy paused\n        //_pause();\n        daysOfPromo = 7;\n    }\n\n    function mintOwner(address _to) external onlyOwner returns (uint256) {\n        return mint(_to);\n    }\n\n    function setConfigurationLinkDays(uint256 _amountOfDays, bool _status)\n        external\n        onlyOwner\n    {\n        configurationLinkDays[_amountOfDays] = _status;\n    }\n\n    function mintWithCWOLF()\n        public\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 commissionInBNB = Variables(VariablesContractAddress)\n            .getDollarsInBNB(commissionInDollar);\n        require(msg.value >= (gasToMinter + commissionInBNB), \"Not enough gas\");\n        payable(minterWalletAddress).transfer(gasToMinter);\n        payable(commissionWalletAddress).transfer(commissionInBNB);\n        payable(msg.sender).transfer(\n            msg.value - (gasToMinter + commissionInBNB)\n        );\n\n        uint256 id = mint(msg.sender);\n\n        uint256 _days = DateTimeLibrary.diffDays(\n            dateLastPromoActivation,\n            block.timestamp\n        );\n        if (isPromoActive && _days <= daysOfPromo) {\n            wolfPackInPromo[id] = true;\n        }\n\n        return id;\n    }\n\n    function mint(address _to) internal returns (uint256) {\n        uint256 tokenId = totalSupply();\n        _safeMint(_to, tokenId);\n        emit MintedNFT(_to, tokenId);\n        return tokenId;\n    }\n\n    function createWolfPackAndAddWolfsAndMaterials(\n        uint256[] memory _materialsIds,\n        uint256[] memory _wolfsIds\n    ) external payable returns (bool) {\n        uint256 idWolfPack = mintWithCWOLF();\n        addMultipleMaterialsToWolfPack(idWolfPack, _materialsIds);\n        addMultipleWolfsToWolfPack(idWolfPack, _wolfsIds);\n        return true;\n    }\n\n    function addWolfToWolfPack(uint256 _wolfPackId, uint256 _wolfId)\n        public\n        returns (bool)\n    {\n        require(ownerOf(_wolfPackId) == msg.sender, \"WolfPack property failed\"); // WolfPack must be property of msg.sender\n        require(\n            WolfsNFT(WolfsNFTContractAddress).ownerOf(_wolfId) == msg.sender,\n            \"Wolf property failed\"\n        );\n        require(\n            getTotalSlotsAvailableInWolfPack(_wolfPackId) > 0,\n            \"Max capacity reached\"\n        );\n        require(wolfsUsed[_wolfId] == false, \"Wolf is used in other wolf pack\");\n\n        wolfsUsed[_wolfId] = true;\n        wolfsInWolfPack[_wolfPackId].push(_wolfId);\n        wolfPackLife[_wolfPackId] =\n            wolfPackLife[_wolfPackId] +\n            WolfsNFT(WolfsNFTContractAddress).getWolfProperties(_wolfId)[3] +\n            WolfsNFT(WolfsNFTContractAddress).getWolfProperties(_wolfId)[4];\n\n        uint256 amountCWOLF = Variables(VariablesContractAddress)\n            .getDollarsInCWOLF(addWolfOrMaterialCWOLFInDollar);\n\n        require(\n            IERC20Upgradeable(CWOLFContractAddress).allowance(\n                msg.sender,\n                address(this)\n            ) >= amountCWOLF,\n            \"Not enough allowance\"\n        );\n\n        IERC20Upgradeable(CWOLFContractAddress).transferFrom(\n            msg.sender,\n            rewardsPoolAddress,\n            amountCWOLF\n        );\n        return true;\n    }\n\n    function addMultipleWolfsToWolfPack(\n        uint256 _wolfPackId,\n        uint256[] memory _wolfsIds\n    ) public returns (bool) {\n        for (uint256 index = 0; index < _wolfsIds.length; index++) {\n            addWolfToWolfPack(_wolfPackId, _wolfsIds[index]);\n        }\n        return true;\n    }\n\n    function addMaterialToWolfPack(uint256 _wolfPackId, uint256 _materialId)\n        public\n        returns (bool)\n    {\n        require(ownerOf(_wolfPackId) == msg.sender, \"WolfPack property failed\"); // WolfPack must be property of msg.sender\n        require(\n            MaterialsNFT(MaterialsNFTContractAddress).ownerOf(_materialId) ==\n                msg.sender,\n            \"Material property failed\"\n        );\n        require(\n            getTotalMaterialsInWolfPack(_wolfPackId) < 20,\n            \"Limit 20 reached\"\n        );\n        require(\n            materialsUsed[_materialId] == false,\n            \"Material is used in other wolf pack\"\n        );\n\n        materialsInWolfPack[_wolfPackId].push(_materialId);\n        materialsUsed[_materialId] = true;\n\n        uint256 amountCWOLF = Variables(VariablesContractAddress)\n            .getDollarsInCWOLF(addWolfOrMaterialCWOLFInDollar);\n\n        require(\n            IERC20Upgradeable(CWOLFContractAddress).allowance(\n                msg.sender,\n                address(this)\n            ) >= amountCWOLF,\n            \"Not enough allowance\"\n        );\n\n        IERC20Upgradeable(CWOLFContractAddress).transferFrom(\n            msg.sender,\n            rewardsPoolAddress,\n            amountCWOLF\n        );\n        return true;\n    }\n\n    function addMultipleMaterialsToWolfPack(\n        uint256 _wolfPackId,\n        uint256[] memory _materialsIds\n    ) public returns (bool) {\n        for (uint256 index = 0; index < _materialsIds.length; index++) {\n            addMaterialToWolfPack(_wolfPackId, _materialsIds[index]);\n        }\n        return true;\n    }\n\n    function addMultipleMaterialsAndWolfsToWolfPack(\n        uint256 _wolfPackId,\n        uint256[] memory _materialsIds,\n        uint256[] memory _wolfsIds\n    ) external returns (bool) {\n        for (uint256 index = 0; index < _materialsIds.length; index++) {\n            addMaterialToWolfPack(_wolfPackId, _materialsIds[index]);\n        }\n\n        for (uint256 index = 0; index < _wolfsIds.length; index++) {\n            addWolfToWolfPack(_wolfPackId, _wolfsIds[index]);\n        }\n\n        return true;\n    }\n\n    function destroyWolfPack(uint256 _wolfPackId) external returns (bool) {\n        require(ownerOf(_wolfPackId) == msg.sender, \"WolfPack property failed\"); // WolfPack must be property of msg.sender\n\n        // Delete used Wolfs from mapping\n        uint256[] memory wolfsIdsInWolfPack = wolfsInWolfPack[_wolfPackId];\n        for (uint256 index = 0; index < wolfsIdsInWolfPack.length; index++) {\n            wolfsUsed[wolfsIdsInWolfPack[index]] = false;\n        }\n\n        // Delete array of WOLFs from mapping\n        delete wolfsInWolfPack[_wolfPackId];\n\n        // Delete used Materials from mapping\n        uint256[] memory materialsIdsInWolfPack = materialsInWolfPack[\n            _wolfPackId\n        ];\n        for (\n            uint256 index = 0;\n            index < materialsIdsInWolfPack.length;\n            index++\n        ) {\n            materialsUsed[materialsIdsInWolfPack[index]] = false;\n        }\n\n        // Delete array of Materials from mapping\n        delete materialsInWolfPack[_wolfPackId];\n\n        wolfPackInPromo[_wolfPackId] = false;\n        safeTransferFrom(msg.sender, rewardsPoolAddress, _wolfPackId);\n\n        return true;\n    }\n\n    function buyEnergy(uint256 _wolfPackId, uint256 _amountCWOLF) external {\n        require(ownerOf(_wolfPackId) == msg.sender, \"Owner of WolfPack failed\");\n        uint256 _amountInDollar = Variables(VariablesContractAddress)\n            .getDollarsInCWOLF(_amountCWOLF);\n        require(\n            _amountInDollar >= energyPointPriceInCWOLF,\n            \"The amount is not valid\"\n        );\n\n        require(\n            IERC20Upgradeable(CWOLFContractAddress).allowance(\n                msg.sender,\n                address(this)\n            ) >= _amountCWOLF,\n            \"Not enough allowance\"\n        );\n\n        IERC20Upgradeable(CWOLFContractAddress).transferFrom(\n            msg.sender,\n            rewardsPoolAddress,\n            _amountCWOLF\n        );\n        wolfPackEnergy[_wolfPackId] =\n            wolfPackEnergy[_wolfPackId] +\n            _amountInDollar;\n        emit IncreasedEnergy(_wolfPackId, _amountInDollar);\n    }\n\n    function decreaseEnergy(uint256 _wolfPackId, uint256 _amountToDecrease)\n        external\n    {\n        require(\n            msg.sender == HuntingNFTContractAddress,\n            \"Caller is not Hunting contract\"\n        );\n        require(\n            wolfPackEnergy[_wolfPackId] - _amountToDecrease >= 0,\n            \"Error: Amount to decrease greater than energy\"\n        );\n        wolfPackEnergy[_wolfPackId] =\n            wolfPackEnergy[_wolfPackId] -\n            _amountToDecrease;\n        emit DecreasedEnergy(_wolfPackId, _amountToDecrease);\n    }\n\n    function decreaseWolfPackLife(\n        uint256 _wolfPackId,\n        uint256 _amountToDecrease\n    ) external {\n        require(\n            msg.sender == HuntingNFTContractAddress,\n            \"Caller is not Hunting contract\"\n        );\n        if (wolfPackLife[_wolfPackId] - _amountToDecrease > 0) {\n            wolfPackLife[_wolfPackId] =\n                wolfPackLife[_wolfPackId] -\n                _amountToDecrease;\n            emit DecreasedLife(_wolfPackId, _amountToDecrease);\n        } else {\n            wolfPackLife[_wolfPackId] = 0;\n            emit DecreasedLife(_wolfPackId, 0);\n        }\n    }\n\n    function setDaysOfPromo(uint256 _newDaysOfPromo)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        daysOfPromo = _newDaysOfPromo;\n        return true;\n    }\n\n    function activatePromo() external onlyOwner returns (bool) {\n        isPromoActive = true;\n        dateLastPromoActivation = block.timestamp;\n        return true;\n    }\n\n    function deactivatePromo() external onlyOwner returns (bool) {\n        isPromoActive = false;\n        dateLastPromoActivation = 0;\n        return true;\n    }\n\n    function setPromoStatusForWolfPack(uint256 _wolfPackId, bool _status)\n        external\n        returns (bool)\n    {\n        require(\n            msg.sender == owner() || msg.sender == HuntingNFTContractAddress\n        );\n        wolfPackInPromo[_wolfPackId] = _status;\n        return true;\n    }\n\n    function checkWolfPackStatusPromo(uint256 _wolfPackId)\n        external\n        view\n        returns (bool)\n    {\n        return wolfPackInPromo[_wolfPackId];\n    }\n\n    // Checks the status of the wolfpack life: > 0 is alive and true, otherwise dead and false\n    function checkWolfPackStatusDeadOrAlive(uint256 _wolfPackId)\n        external\n        view\n        returns (bool)\n    {\n        return wolfPackLife[_wolfPackId] > 0;\n    }\n\n    function buyWolfPackLink(uint256 _wolfPackId, uint256 _amountOfDays)\n        external\n    {\n        require(ownerOf(_wolfPackId) == msg.sender, \"Owner of WolfPack failed\");\n        require(\n            configurationLinkDays[_amountOfDays] == true,\n            \"Error: Amount of days incorrect\"\n        );\n        uint256 priceOfCWOLFInDollar = Variables(VariablesContractAddress)\n            .priceCWOLF();\n        uint256 totalDollars = ((_amountOfDays * 10**18) * 5000) / 10000;\n        uint256 amountInCWOLF = (priceOfCWOLFInDollar *\n            totalDollars *\n            wolfsInWolfPack[_wolfPackId].length) / 10**18;\n\n        require(\n            IERC20Upgradeable(CWOLFContractAddress).allowance(\n                msg.sender,\n                address(this)\n            ) >= amountInCWOLF,\n            \"Not enough allowance\"\n        );\n\n        IERC20Upgradeable(CWOLFContractAddress).transferFrom(\n            msg.sender,\n            rewardsPoolAddress,\n            amountInCWOLF\n        );\n\n        if (wolfPackLinkDate[_wolfPackId] == 0) {\n            wolfPackLinkDate[_wolfPackId] = block.timestamp;\n        }\n\n        uint256 differenceDays = DateTimeLibrary.diffDays(\n            wolfPackLinkDate[_wolfPackId],\n            block.timestamp\n        );\n\n        if (wolfPackLinkDays[_wolfPackId] - differenceDays < 0) {\n            wolfPackLinkDays[_wolfPackId] = 0;\n        } else {\n            wolfPackLinkDays[_wolfPackId] =\n                wolfPackLinkDays[_wolfPackId] -\n                differenceDays;\n        }\n\n        wolfPackLinkDays[_wolfPackId] =\n            wolfPackLinkDays[_wolfPackId] +\n            _amountOfDays;\n\n        emit IncreasedLink(_wolfPackId, wolfPackLinkDays[_wolfPackId]);\n    }\n\n    function checkWolfPackLink(uint256 _wolfPackId, uint256 _toTimestamp)\n        external\n        view\n        returns (bool)\n    {\n        console.log(\"1:\", _wolfPackId);\n        console.log(\"from :\", _toTimestamp);\n        console.log(\n            \"wolfPackLinkDate[_wolfPackId] :\",\n            wolfPackLinkDate[_wolfPackId]\n        );\n\n        uint256 differenceDays = DateTimeLibrary.diffDays(\n            wolfPackLinkDate[_wolfPackId],\n            _toTimestamp\n        );\n        return differenceDays <= wolfPackLinkDays[_wolfPackId];\n    }\n\n    function calculateGasAndCommissions()\n        public\n        view\n        returns (uint256[3] memory)\n    {\n        uint256 commissionInBNB = Variables(VariablesContractAddress)\n            .getDollarsInBNB(commissionInDollar);\n\n        uint256[3] memory commissions;\n        commissions[0] = gasToMinter;\n        commissions[1] = commissionInBNB;\n        commissions[2] = gasToMinter + commissionInBNB;\n        return commissions;\n    }\n\n    function getTotalMaterialsInWolfPack(uint256 _wolfPackId)\n        public\n        view\n        returns (uint256)\n    {\n        return materialsInWolfPack[_wolfPackId].length;\n    }\n\n    function getTotalSlotsAvailableInWolfPack(uint256 _wolfPackId)\n        public\n        view\n        returns (uint256)\n    {\n        uint256[] memory wolfPack = materialsInWolfPack[_wolfPackId];\n\n        // Capacity of WolfPack\n        uint256 totalCapacity;\n        for (uint256 index = 0; index < wolfPack.length; index++) {\n            uint256 wolfTokenId = wolfPack[index];\n            uint256 materialCapacity = MaterialsNFT(MaterialsNFTContractAddress)\n                .slots(wolfTokenId);\n            totalCapacity = totalCapacity + materialCapacity;\n        }\n\n        return totalCapacity - wolfsInWolfPack[_wolfPackId].length;\n    }\n\n    function getTotalSlotsInWolfPack(uint256 _wolfPackId)\n        public\n        view\n        returns (uint256)\n    {\n        uint256[] memory wolfPack = materialsInWolfPack[_wolfPackId];\n\n        // Capacity of WolfPack\n        uint256 totalCapacity;\n        for (uint256 index = 0; index < wolfPack.length; index++) {\n            uint256 wolfTokenId = wolfPack[index];\n            uint256 materialCapacity = MaterialsNFT(MaterialsNFTContractAddress)\n                .slots(wolfTokenId);\n            totalCapacity = totalCapacity + materialCapacity;\n        }\n\n        return totalCapacity;\n    }\n\n    function pointsOfWolfPack(uint256 _wolfPackId)\n        external\n        view\n        returns (uint256)\n    {\n        require(_exists(_wolfPackId), \"WolfPack not exist\"); // WolfPack must exist\n\n        uint256[] memory wolfsIdsInWolfPack = wolfsInWolfPack[_wolfPackId];\n\n        console.log(\"AAA: \", wolfsIdsInWolfPack.length);\n\n        uint256 totalPoints;\n        console.log(\"Length:\", wolfsIdsInWolfPack.length);\n        for (uint256 index = 0; index < wolfsIdsInWolfPack.length; index++) {\n            totalPoints =\n                totalPoints +\n                WolfsNFT(WolfsNFTContractAddress).getWolfProperties(\n                    wolfsIdsInWolfPack[index]\n                )[3];\n\n            console.log(\n                \"XXX: \",\n                WolfsNFT(WolfsNFTContractAddress).getWolfProperties(\n                    wolfsIdsInWolfPack[index]\n                )[3]\n            );\n        }\n\n        console.log(\"totalPoints: \", totalPoints);\n\n        return totalPoints;\n    }\n\n    function setLastHunting(uint256 _wolfPackId, uint256 _lastHunting)\n        external\n        returns (bool)\n    {\n        // Restricted access only for Hunting Contract\n        require(msg.sender == HuntingNFTContractAddress);\n        lastHunting[_wolfPackId] = _lastHunting;\n        return true;\n    }\n\n    function walletOfOwner(address _owner)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256 tokenCount = balanceOf(_owner);\n        uint256[] memory tokensId = new uint256[](tokenCount);\n        for (uint256 i = 0; i < tokenCount; i++) {\n            tokensId[i] = tokenOfOwnerByIndex(_owner, i);\n        }\n        return tokensId;\n    }\n\n    function changeBaseTokenURI(string memory newBaseTokenURI)\n        external\n        onlyOwner\n    {\n        strBaseTokenURI = newBaseTokenURI;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return strBaseTokenURI;\n    }\n\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        require(_exists(_tokenId), \"Token does not exist\");\n        return string(abi.encodePacked(_baseURI(), _tokenId.toString()));\n    }\n\n    function pause() external onlyOwner returns (bool) {\n        _pause();\n        return true;\n    }\n\n    function unpause() external onlyOwner returns (bool) {\n        _unpause();\n        return true;\n    }\n\n    function changeRewardsPoolAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        rewardsPoolAddress = _newAddress;\n        return true;\n    }\n\n    function changeAddWolfOrMaterialCWOLFInDollar(uint256 _newPrice)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        addWolfOrMaterialCWOLFInDollar = _newPrice;\n        return true;\n    }\n\n    function changeCWOLFContractAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        CWOLFContractAddress = _newAddress;\n        return true;\n    }\n\n    function changeWolfsNFTContractAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        WolfsNFTContractAddress = _newAddress;\n        return true;\n    }\n\n    function changeMaterialsNFTContractAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        MaterialsNFTContractAddress = _newAddress;\n        return true;\n    }\n\n    function changeGasToMinter(uint256 _newValue)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        gasToMinter = _newValue;\n        return true;\n    }\n\n    function changeCommissionInDollar(uint256 _newValue)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        commissionInDollar = _newValue;\n        return true;\n    }\n\n    function changeAddressMinterWallet(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        minterWalletAddress = _newAddress;\n        return true;\n    }\n\n    function changeHuntingNFTContractAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        HuntingNFTContractAddress = _newAddress;\n        return true;\n    }\n\n    function changeAddressCommissionWallet(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        commissionWalletAddress = _newAddress;\n        return true;\n    }\n\n    function nothing() internal pure returns (uint256) {\n        return 2;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/WolfsNFT.sol": {
      "content": "/*\nCRYPTOWOLF\nWeb: https://cryptowolf.finance\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./WolfsNFTHelper.sol\";\nimport \"./Random.sol\";\nimport \"./Variables.sol\";\n\nimport \"hardhat/console.sol\";\n\nimport \"./WolfPacksNFT.sol\";\n\ncontract WolfsNFT is\n    Initializable,\n    ERC721EnumerableUpgradeable,\n    PausableUpgradeable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeMathUpgradeable for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    bool public isInitialized;\n    uint256 public boxPriceCWOLFInDollars;\n    uint256 public gasToMinter;\n    uint256 public commissionInDollars;\n    address public rewardsPoolAddress;\n    address public CWOLFContractAddress;\n    address public wolfsNFTHelperContractAddress;\n    address public VariablesContractAddress;\n    address public minterWalletAddress;\n    address public commissionWalletAddress;\n    string public strBaseTokenURI;\n\n    mapping(uint256 => uint256) public breed;\n    mapping(uint256 => uint256) public gender;\n    mapping(uint256 => uint256) public level;\n    mapping(uint256 => uint256) public attack;\n    mapping(uint256 => uint256) public defense;\n    mapping(uint256 => uint256) public lastHunt;\n    mapping(uint256 => bool) public generated;\n\n    address public WolfPackNFTContractAddress;\n    address public marketPlaceAddress;\n\n    event MintedNFT(address indexed to, uint256 indexed id);\n    event GeneratedNFT(uint256 indexed id);\n\n    constructor() initializer {}\n\n    function initialize(\n        address wolfsNFTHelperContractAddress_,\n        address CWOLFContractAddress_,\n        address VariablesContractAddress_,\n        address rewardsPoolAddress_,\n        address minterWalletAddress_,\n        address commissionWalletAddress_\n    ) public initializer {\n        __ERC721_init(\"WolfNFT\", \"WolfNFT\");\n        __Ownable_init();\n        wolfsNFTHelperContractAddress = wolfsNFTHelperContractAddress_;\n        CWOLFContractAddress = CWOLFContractAddress_;\n        VariablesContractAddress = VariablesContractAddress_;\n        rewardsPoolAddress = rewardsPoolAddress_;\n\n        gasToMinter = 1000000000000000;\n        commissionInDollars = 250000000000000000;\n        minterWalletAddress = minterWalletAddress_;\n        commissionWalletAddress = commissionWalletAddress_;\n        boxPriceCWOLFInDollars = 10000000000000000000;\n\n        // First wolf minted with all to 0\n        // If another contract points to it must be 0\n        _safeMint(minterWalletAddress_, 0);\n        isInitialized = true;\n\n        // Uncomment if we want deploy paused\n        // _pause();\n    }\n\n    function mintOwner(address _to) external onlyOwner returns (uint256) {\n        return mint(_to);\n    }\n\n    function mintWithCWOLF(uint8 _amount)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (bool)\n    {\n        require(_amount <= 10, \"Amount must be < 10\");\n        uint256 commissionInBNB = Variables(VariablesContractAddress)\n            .getDollarsInBNB(commissionInDollars);\n        require(\n            msg.value >=\n                ((gasToMinter * _amount) + (commissionInBNB * _amount)),\n            \"Not enough gas\"\n        );\n        payable(minterWalletAddress).transfer(gasToMinter * _amount);\n        payable(commissionWalletAddress).transfer((commissionInBNB * _amount));\n        payable(msg.sender).transfer(\n            msg.value - ((gasToMinter * _amount) + (commissionInBNB * _amount))\n        );\n\n        uint256 amountCWOLF = Variables(VariablesContractAddress)\n            .getDollarsInCWOLF(boxPriceCWOLFInDollars) * _amount;\n\n        require(\n            IERC20Upgradeable(CWOLFContractAddress).allowance(\n                msg.sender,\n                address(this)\n            ) >= amountCWOLF,\n            \"Not enough allowance\"\n        );\n\n        IERC20Upgradeable(CWOLFContractAddress).transferFrom(\n            msg.sender,\n            rewardsPoolAddress,\n            amountCWOLF\n        );\n\n        for (uint256 index = 0; index < _amount; index++) {\n            mint(msg.sender);\n        }\n\n        return true;\n    }\n\n    function mint(address _to) internal returns (uint256) {\n        uint256 tokenId = totalSupply();\n        _safeMint(_to, tokenId);\n        emit MintedNFT(_to, tokenId);\n        return tokenId;\n    }\n\n    function calculateGasAndCommissions(uint8 _amount)\n        public\n        view\n        returns (uint256[3] memory)\n    {\n        uint256 commissionInBNB = Variables(VariablesContractAddress)\n            .getDollarsInBNB(commissionInDollars);\n\n        uint256[3] memory commissions;\n        commissions[0] = gasToMinter * _amount;\n        commissions[1] = commissionInBNB * _amount;\n        commissions[2] = ((gasToMinter * _amount) +\n            (commissionInBNB * _amount));\n        return commissions;\n    }\n\n    function burnWolf(uint256 _tokenId) public returns (bool) {\n        require(ownerOf(_tokenId) == msg.sender, \"Owner of WolfNFT failed\");\n        bool isUsed = WolfPacksNFT(WolfPackNFTContractAddress).wolfsUsed(\n            _tokenId\n        );\n        require(isUsed == false, \"Wolf cannot be burned during its use\");\n\n        safeTransferFrom(msg.sender, rewardsPoolAddress, _tokenId);\n\n        uint256 amountCWOLF = Variables(VariablesContractAddress)\n            .getDollarsInCWOLF(boxPriceCWOLFInDollars);\n\n        uint256 amountToReturn = (amountCWOLF * 2000) / 10000;\n\n        IERC20Upgradeable(CWOLFContractAddress).transferFrom(\n            rewardsPoolAddress,\n            msg.sender,\n            amountToReturn\n        );\n\n        return true;\n    }\n\n    function getWolfProperties(uint256 _tokenId)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        require(_exists(_tokenId), \"Token does not exist\");\n        uint256[] memory properties = new uint256[](6);\n\n        properties[0] = breed[_tokenId];\n        properties[1] = gender[_tokenId];\n        properties[2] = level[_tokenId];\n        properties[3] = attack[_tokenId];\n        properties[4] = defense[_tokenId];\n        properties[5] = lastHunt[_tokenId];\n\n        return properties;\n    }\n\n    function generateValuesWolf(uint256[] memory _tokenIds, bytes32 _seed)\n        external\n        returns (bool)\n    {\n        for (uint256 index = 0; index < _tokenIds.length; index++) {\n            uint256 tokenId = _tokenIds[index];\n\n            require(generated[tokenId] == false, \"Wolf yet generated\");\n            require(tokenId != 0, \"Not allowed\");\n            require(\n                msg.sender == owner() || msg.sender == minterWalletAddress,\n                \"Not allowed\"\n            );\n            require(_exists(tokenId), \"Token does not exist\");\n\n            WolfsNFTHelper wolfNFTHelper = WolfsNFTHelper(\n                wolfsNFTHelperContractAddress\n            );\n\n            (\n                uint256 breedGenerated,\n                uint256 genderGenerated,\n                uint256 levelGenerated,\n                uint256 attackGenerated,\n                uint256 defenseGenerated\n            ) = wolfNFTHelper.generateWolf(\n                    keccak256(abi.encodePacked(_seed, index))\n                );\n\n            breed[tokenId] = breedGenerated;\n            gender[tokenId] = genderGenerated;\n            level[tokenId] = levelGenerated;\n            attack[tokenId] = attackGenerated;\n            defense[tokenId] = defenseGenerated;\n            generated[tokenId] = true;\n\n            emit GeneratedNFT(tokenId);\n        }\n\n        return true;\n    }\n\n    function walletOfOwner(address _owner)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256 tokenCount = balanceOf(_owner);\n        uint256[] memory tokensId = new uint256[](tokenCount);\n        for (uint256 i = 0; i < tokenCount; i++) {\n            tokensId[i] = tokenOfOwnerByIndex(_owner, i);\n        }\n        return tokensId;\n    }\n\n    function changeBaseTokenURI(string memory newBaseTokenURI)\n        external\n        onlyOwner\n    {\n        strBaseTokenURI = newBaseTokenURI;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return strBaseTokenURI;\n    }\n\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        require(_exists(_tokenId), \"Token does not exist\");\n        return string(abi.encodePacked(_baseURI(), _tokenId.toString()));\n    }\n\n    function pauseContract() external onlyOwner returns (bool) {\n        _pause();\n        return true;\n    }\n\n    function unpauseContract() external onlyOwner returns (bool) {\n        _unpause();\n        return true;\n    }\n\n    function changeCWOLFContractAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        CWOLFContractAddress = _newAddress;\n        return true;\n    }\n\n    function changeRewardsPoolAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        rewardsPoolAddress = _newAddress;\n        return true;\n    }\n\n    function changeGasToMinter(uint256 _newValue)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        gasToMinter = _newValue;\n        return true;\n    }\n\n    function changeCommissionInDollars(uint256 _newValue)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        commissionInDollars = _newValue;\n        return true;\n    }\n\n    function changeboxPriceCWOLFInDollars(uint256 _newValue)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        boxPriceCWOLFInDollars = _newValue;\n        return true;\n    }\n\n    function changeWolfsNFTHelperContractAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        wolfsNFTHelperContractAddress = _newAddress;\n        return true;\n    }\n\n    function changeAddressMinterWallet(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        minterWalletAddress = _newAddress;\n        return true;\n    }\n\n    function changeAddressCommissionWallet(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        commissionWalletAddress = _newAddress;\n        return true;\n    }\n\n    function changeWolfPackNFTContractAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        WolfPackNFTContractAddress = _newAddress;\n        return true;\n    }\n\n    function changeMarketplaceContractAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        marketPlaceAddress = _newAddress;\n        return true;\n    }\n\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _tokenId);\n        if (\n            _from != address(0) &&\n            _to != address(0) &&\n            (msg.sender != marketPlaceAddress || msg.sender != _from)\n        ) {\n            revert(\"Only CW MarketPlace allowed\");\n        }\n    }\n}\n"
    },
    "contracts/Hunting.sol": {
      "content": "/*\nCRYPTOWOLF\nWeb: https://cryptowolf.finance\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n// import \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./DateTimeLibrary.sol\";\n\nimport \"./WolfsNFT.sol\";\nimport \"./WolfPacksNFT.sol\";\n\ncontract HuntingNFT is\n    Initializable,\n    ERC721EnumerableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable\n{\n    using SafeMathUpgradeable for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    // using DateTimeLibrary for uint256;\n\n    bool public isInitialized;\n    uint256 public boxPriceCWOLF;\n    uint256 public gasToMinter;\n    address public rewardsPoolAddress;\n    address public CWOLFContractAddress;\n    address public WolfPackNFTContractAddress;\n    address public minterWalletAddress;\n    string public strBaseTokenURI;\n\n    uint256[] public animalsPoints;\n    uint256[] public animalsProbability;\n    uint256[] public animalsRewards;\n\n    mapping(uint256 => uint256) public wolfPackId;\n    mapping(uint256 => uint256) public positionToAttack;\n    mapping(uint256 => uint256) public dateOfHunting;\n    mapping(uint256 => uint256) public rewards;\n    mapping(uint256 => bool) public isGenerated;\n    mapping(uint256 => bool) public isClaimed;\n\n    // TODO:  Al día sólo se puede cazar una vez.  Los contadores se resetean a las 00:00\n    // Cómo implementaría yo esto:\n    // https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n    // Yo haria una función para calcular la última vez que cazó la manada.\n\n    // Cuando se crea el NFT de ataque, tenemos que guardar a qué animal atacan, probabilidad en ese momento y premio en ese momento ?\n    // Lo necesita el backend luego para calcular el resultado de la lucha.\n\n    // Mirar el tema de las recompensas.  Tienen vesting.  COSA CHUNGA\n\n    event MintedNFT(address indexed to, uint256 indexed id);\n    event GeneratedResultNFT(uint256 indexed tokenId); // Revisar qué parametros son necesarios\n\n    constructor() initializer {}\n\n    function initialize(\n        address CWOLFContractAddress_,\n        address rewardsPoolAddress_,\n        address minterWalletAddress_,\n        address WolfPackNFTContractAddress_\n    ) public initializer {\n        __ERC721_init(\"HuntingNFT\", \"HuntingNFT\");\n        __Ownable_init();\n        CWOLFContractAddress = CWOLFContractAddress_;\n        rewardsPoolAddress = rewardsPoolAddress_;\n        gasToMinter = 1000000000000000;\n        minterWalletAddress = minterWalletAddress_;\n        WolfPackNFTContractAddress = WolfPackNFTContractAddress_;\n\n        animalsPoints = [\n            300,\n            600,\n            900,\n            1200,\n            1500,\n            1800,\n            2000,\n            2200,\n            2400,\n            2600,\n            2800,\n            3000,\n            3200,\n            3400,\n            3600,\n            3800,\n            4000,\n            4100,\n            4400,\n            4700,\n            5000,\n            5300,\n            5600,\n            5900,\n            6300,\n            6500,\n            6800,\n            7100,\n            7400,\n            7700,\n            8000\n        ];\n\n        animalsProbability = [\n            90,\n            90,\n            90,\n            85,\n            80,\n            76,\n            72,\n            68,\n            64,\n            62,\n            60,\n            58,\n            56,\n            54,\n            52,\n            50,\n            50,\n            50,\n            50,\n            50,\n            50,\n            50,\n            50,\n            50,\n            50,\n            50,\n            50,\n            50,\n            50,\n            50,\n            50\n        ];\n\n        animalsRewards = [\n            9,\n            18,\n            27,\n            38,\n            51,\n            61,\n            73,\n            86,\n            103,\n            125,\n            139,\n            155,\n            171,\n            188,\n            219,\n            232,\n            246,\n            259,\n            272,\n            302,\n            331,\n            359,\n            388,\n            416,\n            474,\n            505,\n            535,\n            566,\n            596,\n            627\n        ];\n\n        // First WOLFPACK must be 0 capacity\n        _safeMint(minterWalletAddress_, 0);\n        isInitialized = true;\n        // Uncomment if we want deploy paused\n        // _pause();\n    }\n\n    function mintWithCWOLF(uint256 _wolfPackId, uint256 _positionToAttack)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (bool)\n    {\n        // Comprobar que la manada sea del msg.sender\n        require(\n            WolfPacksNFT(WolfPackNFTContractAddress).ownerOf(_wolfPackId) ==\n                msg.sender,\n            \"You are not the owner\"\n        );\n\n        // Revisamos que la manada pueda ir a cazar\n        checkWolfPack(_wolfPackId, _positionToAttack);\n\n        require(msg.value >= gasToMinter, \"Not enough gas\");\n\n        payable(minterWalletAddress).transfer(gasToMinter);\n        payable(msg.sender).transfer(msg.value - gasToMinter);\n\n        require(\n            IERC20Upgradeable(CWOLFContractAddress).allowance(\n                msg.sender,\n                address(this)\n            ) >= boxPriceCWOLF,\n            \"Not enough allowance\"\n        );\n\n        IERC20Upgradeable(CWOLFContractAddress).transferFrom(\n            msg.sender,\n            rewardsPoolAddress,\n            boxPriceCWOLF\n        );\n\n        uint256 huntingId = mint(msg.sender);\n\n        wolfPackId[huntingId] = _wolfPackId;\n        positionToAttack[huntingId] = _positionToAttack;\n        dateOfHunting[huntingId] = block.timestamp;\n\n        return true;\n    }\n\n    function checkWolfPack(uint256 _wolfPackId, uint256 _positionToAttack)\n        public\n        view\n        returns (bool)\n    {\n        WolfPacksNFT wolfPacksNFT = WolfPacksNFT(WolfPackNFTContractAddress);\n        uint256 pointsOfWolfPack = wolfPacksNFT.pointsOfWolfPack(_wolfPackId);\n\n        // Comprobamos que la manada tenga puntos para poder atacar al animal\n        uint256 animalsPointsToAttack = animalsPoints[_positionToAttack];\n        require(\n            pointsOfWolfPack >= animalsPointsToAttack,\n            \"Not enough points to attack this animal\"\n        );\n\n        // Comprobamos que la manada pueda ir a cazar\n        uint256 lastHunting = WolfPacksNFT(WolfPackNFTContractAddress)\n            .lastHunting(_wolfPackId);\n        if (lastHunting != 0) {\n            uint256 newTs = DateTimeLibrary.timestampFromDate(\n                DateTimeLibrary.getYear(lastHunting),\n                DateTimeLibrary.getMonth(lastHunting),\n                DateTimeLibrary.getDay(lastHunting)\n            );\n\n            require(newTs > lastHunting, \"Only one time per day\");\n        }\n        // // TODO: SUPERIMPORTANTE Comprobar la vida de la manada ¿? -> Es requisito tambien que la manada esté viva (lineas de abajo)\n        bool statusLife = WolfPacksNFT(WolfPackNFTContractAddress)\n            .checkWolfPackStatusDeadOrAlive(_wolfPackId);\n        require(statusLife, \"Your wolfpack is dead\");\n\n        // Mirar que la vida del mapping wolfPackEnergy sea mayor > que 250/10000 recompensa\n        uint256 energy = WolfPacksNFT(WolfPackNFTContractAddress)\n            .wolfPackEnergy(_wolfPackId);\n        uint256 energyCost = (animalsRewards[_positionToAttack] * 250) / 10000;\n        require(energy >= energyCost, \"Your wolfpack are tired\");\n        // Comprobar el vínculo.\n        bool statusLink = WolfPacksNFT(WolfPackNFTContractAddress)\n            .checkWolfPackLink(_wolfPackId, block.timestamp);\n        require(statusLink, \"Your wolfpack haven't got link\");\n        return true;\n    }\n\n    function getWinProbability(uint256 _wolfPackId, uint256 _positionToAttack)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 pointsOfPosition = animalsPoints[_positionToAttack];\n        uint256 probabilityToWin = animalsProbability[_positionToAttack];\n\n        uint256 pointsOfAttack = WolfPacksNFT(WolfPackNFTContractAddress)\n            .pointsOfWolfPack(_wolfPackId);\n        // Si la probabilidad es >= 90 la devolvemos\n        if (probabilityToWin >= 90) {\n            return probabilityToWin;\n        }\n\n        // Si es menor, la aumentamos en función de 1% por cada 100 puntos de exceso\n        // uint256 pointsOfAnimalsToAttack = animalsPoints[_positionToAttack];\n        uint256 excessPoints = pointsOfAttack - pointsOfPosition;\n        uint256 probabilityToSum = (excessPoints / 100);\n        uint256 totalProbability = probabilityToWin + probabilityToSum;\n\n        if (totalProbability >= 90) {\n            return 90;\n        } else {\n            return totalProbability;\n        }\n    }\n\n    function mint(address _to) internal returns (uint256) {\n        uint256 tokenId = totalSupply();\n        _safeMint(_to, tokenId);\n        emit MintedNFT(_to, tokenId);\n        return tokenId;\n    }\n\n    function changeAnimalsPoints(uint256[] memory _newData)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        animalsPoints = _newData;\n        return true;\n    }\n\n    function changeAnimalsProbability(uint256[] memory _newData)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        animalsProbability = _newData;\n        return true;\n    }\n\n    function changeAnimalsRewards(uint256[] memory _newData)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        animalsRewards = _newData;\n        return true;\n    }\n\n    function generateResult(uint256[] memory _huntingIds, bytes32 _seed)\n        external\n        returns (bool)\n    {\n        for (uint256 index = 0; index < _huntingIds.length; index++) {\n            uint256 huntingId = _huntingIds[index];\n\n            require(huntingId != 0, \"Not allowed\");\n            require(\n                msg.sender == owner() || msg.sender == minterWalletAddress,\n                \"Not allowed\"\n            );\n            require(_exists(huntingId), \"Token does not exist\");\n            require(isGenerated[huntingId] == false);\n\n            uint256 positionToAttackAnimals = positionToAttack[huntingId];\n\n            uint256 wolfPackIdLocal = wolfPackId[huntingId];\n\n            uint256 winProbability = getWinProbability(\n                wolfPackIdLocal,\n                positionToAttackAnimals\n            );\n\n            uint256 random = Random.randomMinMax(\n                keccak256(abi.encodePacked(_seed, index)),\n                0,\n                100\n            );\n\n            if (random <= winProbability) {\n                // Remove life\n                uint256 calculateSubLife = (positionToAttackAnimals * 400) /\n                    10000;\n                WolfPacksNFT(WolfPackNFTContractAddress).decreaseWolfPackLife(\n                    wolfPackIdLocal,\n                    calculateSubLife\n                );\n\n                // !!! TODO: RECOMPENSAS\n                rewards[huntingId] = animalsRewards[positionToAttackAnimals];\n                // Enviar al contrato del alemán\n            } else {\n                // User loose\n                uint256 calculateSubLife = (positionToAttackAnimals * 1000) /\n                    10000;\n\n                WolfPacksNFT(WolfPackNFTContractAddress).decreaseWolfPackLife(\n                    wolfPackIdLocal,\n                    calculateSubLife\n                );\n            }\n\n            uint256 calculateSubEnergy = (animalsRewards[\n                positionToAttackAnimals\n            ] * 250) / 10000;\n\n            WolfPacksNFT(WolfPackNFTContractAddress).decreaseEnergy(\n                wolfPackIdLocal,\n                calculateSubEnergy\n            );\n            isGenerated[huntingId] = true;\n\n            emit GeneratedResultNFT(huntingId);\n        }\n\n        return true;\n    }\n\n    function walletOfOwner(address _owner)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256 tokenCount = balanceOf(_owner);\n        uint256[] memory tokensId = new uint256[](tokenCount);\n        for (uint256 i = 0; i < tokenCount; i++) {\n            tokensId[i] = tokenOfOwnerByIndex(_owner, i);\n        }\n        return tokensId;\n    }\n\n    function changeBaseTokenURI(string memory newBaseTokenURI)\n        external\n        onlyOwner\n    {\n        strBaseTokenURI = newBaseTokenURI;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return strBaseTokenURI;\n    }\n\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        require(_exists(_tokenId), \"Token does not exist\");\n        return string(abi.encodePacked(_baseURI(), _tokenId.toString()));\n    }\n\n    function pause() external onlyOwner returns (bool) {\n        _pause();\n        return true;\n    }\n\n    function unpause() external onlyOwner returns (bool) {\n        _unpause();\n        return true;\n    }\n\n    function changeRewardsPool(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        rewardsPoolAddress = _newAddress;\n        return true;\n    }\n\n    function changeBoxPriceCWolf(uint256 _newPrice)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        boxPriceCWOLF = _newPrice;\n        return true;\n    }\n\n    function changeCWOLFContractAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        CWOLFContractAddress = _newAddress;\n        return true;\n    }\n\n    function changeWolfPackNFTContractAddress(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        WolfPackNFTContractAddress = _newAddress;\n        return true;\n    }\n\n    function changeGasToMinter(uint256 _newValue)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        gasToMinter = _newValue;\n        return true;\n    }\n\n    function changeAddressMinterWallet(address _newAddress)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        minterWalletAddress = _newAddress;\n        return true;\n    }\n}\n"
    },
    "contracts/WolfsNFTHelper.sol": {
      "content": "/*\nCRYPTOWOLF\nWeb: https://cryptowolf.finance\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./Random.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract WolfsNFTHelper is Initializable, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    /*\n\n    # BREED\n    LAND: 0\n    WATER: 1\n    ICE: 2\n    FIRE: 3\n    FOREST: 4\n    AIR: 5\n    ELECTRIC: 6\n    LEGENDARY: 7\n\n\n    # GENDER\n    MALE: 0\n    FEMALE: 1\n    }\n\n    # LEVEL \n    WOOD: 0\n    BRONZE: 1\n    SILVER: 2\n    GOLD: 3\n    PLATINUM: 4\n    DIAMOND: 5\n\n    */\n\n    bool public isInitialized;\n    uint256[] private breedPercentages;\n    uint256[] private attackDefensePercentages;\n    uint256[] private attackLevels;\n    uint256[][] private attackDefenseLevels;\n\n    constructor() initializer {}\n\n    function initialize() public initializer {\n        __Ownable_init();\n\n        breedPercentages = [14, 14, 14, 14, 14, 14, 14, 2];\n        attackDefensePercentages = [54, 24, 12, 6, 3, 1];\n\n        attackDefenseLevels = [\n            [20, 49],\n            [50, 75],\n            [76, 113],\n            [114, 143],\n            [144, 184],\n            [185, 222]\n        ];\n\n        isInitialized = true;\n    }\n\n    function generateBreed(bytes32 _seed) internal view returns (uint256) {\n        uint256 randomNumber = Random.randomMinMax(\n            keccak256(abi.encodePacked(_seed, uint256(10000))),\n            1,\n            100\n        );\n\n        if (randomNumber <= breedPercentages[0]) {\n            return 0;\n        } else if (\n            randomNumber > sumPercentages(1, breedPercentages) &&\n            randomNumber <= sumPercentages(2, breedPercentages)\n        ) {\n            return 1;\n        } else if (\n            randomNumber > sumPercentages(2, breedPercentages) &&\n            randomNumber <= sumPercentages(3, breedPercentages)\n        ) {\n            return 2;\n        } else if (\n            randomNumber > sumPercentages(3, breedPercentages) &&\n            randomNumber <= sumPercentages(4, breedPercentages)\n        ) {\n            return 3;\n        } else if (\n            randomNumber > sumPercentages(4, breedPercentages) &&\n            randomNumber <= sumPercentages(5, breedPercentages)\n        ) {\n            return 4;\n        } else if (\n            randomNumber > sumPercentages(5, breedPercentages) &&\n            randomNumber <= sumPercentages(6, breedPercentages)\n        ) {\n            return 5;\n        } else if (\n            randomNumber > sumPercentages(6, breedPercentages) &&\n            randomNumber <= sumPercentages(7, breedPercentages)\n        ) {\n            return 6;\n        } else if (\n            randomNumber > sumPercentages(7, breedPercentages) &&\n            randomNumber <= sumPercentages(8, breedPercentages)\n        ) {\n            return 7;\n        }\n        return 0;\n    }\n\n    function generateGender(bytes32 _seed) internal pure returns (uint256) {\n        uint256 randomNumber = Random.randomMinMax(\n            keccak256(abi.encodePacked(_seed, uint256(20000))),\n            0,\n            1\n        );\n\n        if (randomNumber == 0) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n\n    function generateLevels(bytes32 _seed)\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 randomNumber = Random.randomMinMax(_seed, 1, 100);\n\n        bytes32 seed1 = _seed;\n        bytes32 seed2 = keccak256(abi.encode(_seed));\n\n        uint256 attack;\n        uint256 defense;\n        uint256 level;\n\n        if (randomNumber <= attackDefensePercentages[0]) {\n            attack = Random.randomMinMax(\n                seed1,\n                attackDefenseLevels[0][0],\n                attackDefenseLevels[0][1]\n            );\n            defense = Random.randomMinMax(\n                seed2,\n                attackDefenseLevels[0][0],\n                attackDefenseLevels[0][1]\n            );\n            level = 0;\n        } else if (\n            randomNumber > sumPercentages(1, attackDefensePercentages) &&\n            randomNumber <= sumPercentages(2, attackDefensePercentages)\n        ) {\n            attack = Random.randomMinMax(\n                seed1,\n                attackDefenseLevels[1][0],\n                attackDefenseLevels[1][1]\n            );\n            defense = Random.randomMinMax(\n                seed2,\n                attackDefenseLevels[1][0],\n                attackDefenseLevels[1][1]\n            );\n            level = 1;\n        } else if (\n            randomNumber > sumPercentages(2, attackDefensePercentages) &&\n            randomNumber <= sumPercentages(3, attackDefensePercentages)\n        ) {\n            attack = Random.randomMinMax(\n                seed1,\n                attackDefenseLevels[2][0],\n                attackDefenseLevels[2][1]\n            );\n            defense = Random.randomMinMax(\n                seed2,\n                attackDefenseLevels[2][0],\n                attackDefenseLevels[2][1]\n            );\n            level = 2;\n        } else if (\n            randomNumber > sumPercentages(3, attackDefensePercentages) &&\n            randomNumber <= sumPercentages(4, attackDefensePercentages)\n        ) {\n            attack = Random.randomMinMax(\n                seed1,\n                attackDefenseLevels[3][0],\n                attackDefenseLevels[3][1]\n            );\n            defense = Random.randomMinMax(\n                seed2,\n                attackDefenseLevels[3][0],\n                attackDefenseLevels[3][1]\n            );\n            level = 3;\n        } else if (\n            randomNumber > sumPercentages(4, attackDefensePercentages) &&\n            randomNumber <= sumPercentages(5, attackDefensePercentages)\n        ) {\n            attack = Random.randomMinMax(\n                seed1,\n                attackDefenseLevels[4][0],\n                attackDefenseLevels[4][1]\n            );\n            defense = Random.randomMinMax(\n                seed2,\n                attackDefenseLevels[4][0],\n                attackDefenseLevels[4][1]\n            );\n            level = 4;\n        } else if (\n            randomNumber > sumPercentages(5, attackDefensePercentages) &&\n            randomNumber <= sumPercentages(6, attackDefensePercentages)\n        ) {\n            attack = Random.randomMinMax(\n                seed1,\n                attackDefenseLevels[5][0],\n                attackDefenseLevels[5][1]\n            );\n            defense = Random.randomMinMax(\n                seed2,\n                attackDefenseLevels[5][0],\n                attackDefenseLevels[5][1]\n            );\n            level = 5;\n        }\n\n        return (attack, defense, level);\n    }\n\n    function generateWolf(bytes32 _seed)\n        external\n        view\n        returns (\n            uint256 breed,\n            uint256 gender,\n            uint256 level,\n            uint256 attack,\n            uint256 defense\n        )\n    {\n        uint256 breedGenerated = generateBreed(_seed);\n        uint256 genderGenerated = generateGender(_seed);\n        (\n            uint256 attackGenerated,\n            uint256 defenseGenerated,\n            uint256 levelGenerated\n        ) = generateLevels(_seed);\n\n        return (\n            breedGenerated,\n            genderGenerated,\n            levelGenerated,\n            attackGenerated,\n            defenseGenerated\n        );\n    }\n\n    function sumPercentages(uint256 index, uint256[] memory percentages)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result;\n        for (uint256 i = 0; i < index; i++) {\n            result = result + percentages[i];\n        }\n        return result;\n    }\n\n    function updateBreedPercentages(uint256[] memory _newPercentages)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        require(_newPercentages.length == 7, \"Array length must have 8 items\");\n\n        uint256 sum;\n        for (uint256 index = 0; index < _newPercentages.length; index++) {\n            sum = sum + _newPercentages[index];\n        }\n        require(sum == 100, \"Array sum must be 100\");\n\n        breedPercentages[0] = _newPercentages[0];\n        breedPercentages[1] = _newPercentages[1];\n        breedPercentages[2] = _newPercentages[2];\n        breedPercentages[3] = _newPercentages[3];\n        breedPercentages[4] = _newPercentages[4];\n        breedPercentages[5] = _newPercentages[5];\n        breedPercentages[6] = _newPercentages[6];\n        breedPercentages[7] = _newPercentages[7];\n        return true;\n    }\n\n    function updateAttackDefensePercentages(uint256[] memory _newPercentages)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        require(_newPercentages.length == 5, \"Array length must have 6 items\");\n\n        uint256 sum;\n        for (uint256 index = 0; index < _newPercentages.length; index++) {\n            sum = sum + _newPercentages[index];\n        }\n        require(sum == 100, \"Array sum must be 100\");\n\n        attackDefensePercentages[0] = _newPercentages[0];\n        attackDefensePercentages[1] = _newPercentages[1];\n        attackDefensePercentages[2] = _newPercentages[2];\n        attackDefensePercentages[3] = _newPercentages[3];\n        attackDefensePercentages[4] = _newPercentages[4];\n        attackDefensePercentages[5] = _newPercentages[5];\n        return true;\n    }\n\n    function updateAttackDefenseLevels(uint256[][] memory _newData)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        attackDefenseLevels[0] = _newData[0];\n        attackDefenseLevels[1] = _newData[1];\n        attackDefenseLevels[2] = _newData[2];\n        attackDefenseLevels[3] = _newData[3];\n        attackDefenseLevels[4] = _newData[4];\n        attackDefenseLevels[5] = _newData[5];\n        return true;\n    }\n}\n"
    },
    "contracts/CWolfToken.sol": {
      "content": "/*\nCRYPTOWOLF\nWeb: https://cryptowolf.finance\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20CappedUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract CWolfToken is\n    Initializable,\n    ERC20CappedUpgradeable,\n    OwnableUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    bool public isInitialized;\n\n    constructor() initializer {}\n\n    function initialize() public initializer {\n        __ERC20Capped_init(100 * 1e6 * 1e18);\n        __Ownable_init();\n        __ERC20_init(\"CWOLF Token\", \"CWOLF\");\n        isInitialized = true;\n    }\n\n    function burn(address _account, uint256 _amount) external returns (bool) {\n        _burn(_account, _amount);\n        return true;\n    }\n\n    function mint(address _account, uint256 _amount)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        _mint(_account, _amount);\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20CappedUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/ERC20Capped.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\n */\nabstract contract ERC20CappedUpgradeable is Initializable, ERC20Upgradeable {\n    uint256 private _cap;\n\n    /**\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n     * set once during construction.\n     */\n    function __ERC20Capped_init(uint256 cap_) internal initializer {\n        __Context_init_unchained();\n        __ERC20Capped_init_unchained(cap_);\n    }\n\n    function __ERC20Capped_init_unchained(uint256 cap_) internal initializer {\n        require(cap_ > 0, \"ERC20Capped: cap is 0\");\n        _cap = cap_;\n    }\n\n    /**\n     * @dev Returns the cap on the token's total supply.\n     */\n    function cap() public view virtual returns (uint256) {\n        return _cap;\n    }\n\n    /**\n     * @dev See {ERC20-_mint}.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        require(ERC20Upgradeable.totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\");\n        super._mint(account, amount);\n    }\n    uint256[50] private __gap;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}